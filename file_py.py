# -*- coding: utf-8 -*-
"""file.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uE9198vVonAJQjdVSBKlrkfn7ogw9B5w
"""

import streamlit as st
import pandas as pd
import joblib
import matplotlib.pyplot as plt

st.set_page_config(layout="wide")
st.title("Apple Stock Price Prediction using ARIMA")

# Load the pre-trained ARIMA model
# Make sure 'arima_model.joblib' is in the same directory as this Streamlit app
try:
    model = joblib.load('arima_model.joblib')
    st.success("ARIMA model loaded successfully!")
except FileNotFoundError:
    st.error("Error: 'arima_model.joblib' not found. Please ensure the model file is in the correct directory.")
    st.stop()

# Get the last date from the training data for forecasting context
# Assuming train_data was used to fit the model and is available (or can be inferred)
# For simplicity, let's use the last date from the original df if it's still in memory
# In a real deployment, you'd save/load this info with the model or derive from new data

# To make this self-contained for deployment, let's assume we can load enough historical data
# or pass the last observed value to the model for forecasting.
# For now, we'll use the 'train_data' global variable from the notebook context for last date.
# In a deployed app, you'd pass the last 'n' observations to the forecast method.

# We need the last observation from the training data to start forecasting
# As 'train_data' is a Series, its last index is the last date it contains
last_train_date = train_data.index[-1]
last_train_value = train_data.iloc[-1]

st.write(f"Model trained up to: {last_train_date.strftime('%Y-%m-%d')}")
st.write(f"Last observed closing price (from training data): ${last_train_value:.2f}")

st.sidebar.header("Prediction Settings")
num_days = st.sidebar.slider("Number of days to forecast:", min_value=1, max_value=90, value=30)

if st.sidebar.button("Generate Forecast"):
    st.subheader(f"Forecasting Apple Stock Price for the next {num_days} days")

    # Generate forecast
    # The forecast method of a fitted ARIMA model needs the `steps` parameter
    # and will continue from the end of the data it was fitted on.
    try:
        forecast = model.predict(start=len(train_data), end=len(train_data) + num_days - 1)

        # Create a date range for the forecast
        forecast_dates = pd.date_range(start=last_train_date + pd.Timedelta(days=1), periods=num_days, freq='B') # 'B' for business day

        forecast_df = pd.DataFrame({'Date': forecast_dates, 'Predicted Close': forecast.values})
        forecast_df.set_index('Date', inplace=True)

        st.write("### Predicted Prices:")
        st.dataframe(forecast_df)

        # Plotting the forecast
        st.write("### Forecast Visualization:")
        fig, ax = plt.subplots(figsize=(12, 6))
        ax.plot(train_data.index, train_data, label='Historical Training Data', color='blue')
        # Check if test_data exists and plot it if available
        if 'test_data' in globals() and not test_data.empty:
            ax.plot(test_data.index, test_data, label='Actual Test Data', color='orange')
        ax.plot(forecast_df.index, forecast_df['Predicted Close'], label='Forecasted Prices', color='red', linestyle='--')
        ax.set_title('Apple Stock Price Forecast')
        ax.set_xlabel('Date')
        ax.set_ylabel('Close Price')
        ax.legend()
        ax.grid(True)
        st.pyplot(fig)

    except Exception as e:
        st.error(f"An error occurred during forecasting: {e}")


st.markdown("---")
st.write("This is a demonstration of an ARIMA model for stock price prediction.")
st.write("Disclaimer: Stock market predictions are inherently uncertain. This tool is for educational purposes only and should not be considered financial advice.")